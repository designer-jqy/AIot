# 如果C在古代

## 输入的“帝王既视感”

### `scanf`

从键盘输入到`scanf`读取的整个流程：当我们按下键盘上的任何按键的时候，对应按键的符号都会以**字符的形式**按照**先来后到**的原则依次整齐的排列在内存的缓冲区中，等待`scanf`的"临幸"；当输入字符后键盘按下回车键的，这时候就相当于管家通知`scanf`，告诉它，可以去"选妃"了，然后`scanf`就进入内存缓冲区取数据，从前往后依次"选"，由于从键盘输入的都是从全国各地征集过来的（键盘输入的都是**字符型**），所以需要对它们进行一定的培训和装饰（将键盘输入的合法字符转换成我们需要的类型，比如`scanf("%d", &a)`，就将内存中的字符转换成了十进制的数字）；`scanf`从花名册（内存缓冲区）选取妃子的时候，遇到歪瓜裂枣会（空格、制表符`\t`和换行符`\n`）会跳过，直到选到自己满意的为止，最终，那些被跳过的妃子和被选中的妃子都会在花名册中被除名（系统将跳过和取出的数据从缓冲区释放掉），那剩下的妃子呐？别着急，剩下的妃子会在花名册中存留，等到`scanf`的下一次"选妃"（未被跳过或取出的数据，系统会将它一直放在缓冲区中，直到下一个 `scanf` 来获取）。不过这里得注意，输送来的"妃子"得符合`scanf`的胃口，如果上来的妃子就不符合`scanf`的胃口，那么`scanf`就会龙颜大怒，不选了（比如`scanf("%d", &a)`，希望输入的是十进制整数，但是输入了`a`字母，那么`scanf`直接从缓冲区跳出，进行输出，输出的是一个未初始化的数），但是，这个妃子并不会从花名册中抹除，而是继续留在花名册中，等待别的`scanf`临幸。（这个时候需要使用`fflush(stdin)`清空一下输入缓冲区）

注：如果遇到不挑剔的`scanf`，不管是歪瓜裂枣还是倾国倾城都会被选入宫中，只要是女的就行（`scanf("%c", &a)`，任何数据都会被当作一个字符，不管是数字还是空格、回车、Tab 键它都会取回，因为键盘输入的数据最原始的就是字符型的）

**`scanf `类[说明符](https://www.runoob.com/cprogramming/c-function-scanf.html)：**

| 类型                   | 合格的输入                                                   | 参数的类型     |
| :--------------------- | :----------------------------------------------------------- | :------------- |
| %a、%A                 | 读入一个浮点值(仅 C99 有效)。                                | float *        |
| %c                     | 单个字符：读取下一个字符。如果指定了一个不为 1 的宽度 width，函数会读取 width 个字符，并通过参数传递，把它们存储在数组中连续位置。在末尾不会追加空字符。 | char *         |
| %d                     | 十进制整数：数字前面的 + 或 - 号是可选的。                   | int *          |
| %e、%E、%f、%F、%g、%G | 浮点数：包含了一个小数点、一个可选的前置符号 + 或 -、一个可选的后置字符 e 或 E，以及一个十进制数字。两个有效的实例 -732.103 和 7.12e4 | float *        |
| %i                     | 读入十进制，八进制，十六进制整数 。                          | int *          |
| %o                     | 八进制整数。                                                 | int *          |
| %s                     | 字符串。这将读取连续字符，直到遇到一个空格字符（空格字符可以是空白、换行和制表符）。 | char *         |
| %u                     | 无符号的十进制整数。                                         | unsigned int * |
| %x、%X                 | 十六进制整数。                                               | int *          |
| %p                     | 读入一个指针 。                                              |                |
| %[]                    | 扫描字符集合 。                                              |                |
| %%                     | 读 % 符号。                                                  |                |

**总**：`int scanf(const char *format, ...) `函数从花名册选妃（标准输入流 stdin 读取输入），并根据喜好选择（根据提供的 format 来浏览输入）。

### `getchar()`

`getchar()`也可以挑选妃子，但是其每次只能挑选一个，并且只能是**字符类型**的。

```c
char a;
a = getchar();
//类似于
char a; 
scanf("%c", &a);
```

**总**：`int getchar(void)` 函数也从花名册选妃（从 stdin 读取一个字符），不管是啥歪瓜裂枣都接受，反正就是只有一个，不要白不要。

### `gets()`

`gets()`比`getchar()`进阶了一些，可以挑选多个妃子（实际上是读取一整行的**字符**），但是它没有那么挑剔，只有遇到歪瓜裂枣中的换行符`\n`才会离开。

**注**：由于gets()不检查字符串的大小，必须遇到换行符或文件结尾才会结束输入，因此容易造成缓存溢出的安全性问题，导致程序崩溃，可以使用`fgets()`代替。

```c
char str[80];
gets(str);
//实际效果等同于：
char str[80];
scanf("%[^n]",str);
```

**总**：`char *gets(char *s) ` 函数也从花名册选妃（从 stdin 读取一行到 **s** 所指向的缓冲区），直到遇到一个终止符或 EOF。

### `fgets()`	

`fgets()`相比`gets()`，又升了一级，可以自行选择选妃的数目（读取的最大长度）以及选妃的来源（第三个参数说明从哪个流读取输入），

下面写一个程序：

```c
# include <stdio.h>
int main(void)
{
    char str[20];  /*定义一个最大长度为19, 末尾是'\0'的字符数组来存储字符串*/
    printf("请输入一个字符串:");
    fgets(str, 7, stdin);  /*从输入流stdin即输入缓冲区中读取7个字符到字符数组str中*/
    printf("%s\n", str);
    return 0;
}
/*
输出结果是：
请输入一个字符串:i love youc
i love
*/
```

我们发现输入的是“i love you”，而输出只有“i love”。原因是 fgets() 只指定了读取 7 个字符放到字符数组 str 中。“i love”加上中间的空格和最后的 '\0' 正好是 7 个字符。

那有人会问：“用 fgets() 是不是每次都要去数有多少个字符呢？这样不是很麻烦吗？”不用数！fget() 函数中的 size 如果小于字符串的长度，那么字符串将会被截取；如果 size 大于字符串的长度则多余的部分系统会自动用 '\0' 填充。所以假如你定义的字符数组长度为 n，那么 fgets() 中的 size 就指定为 n–1，留一个给 '\0' 就行了。

但是需要注意的是，如果输入的字符串长度没有超过 n–1，那么系统会将最后输入的换行符 '\n' 保存进来，保存的位置是紧跟输入的字符，然后剩余的空间都用 '\0' 填充。所以此时输出该字符串时 printf 中就不需要加换行符 '\n' 了，因为字符串中已经有了。

下面写一个程序看一下：

```c
# include <stdio.h>
int main(void)
{
    char str[30];
    char *string = str;  //一定要先给指针变量初始化
    printf("请输入字符串：");
    fgets(string, 29, stdin);  //size指定为比字符数组元素少一就行了
    printf("%s", string);  //printf中不需要添加'\n', 因为字符串中已经有了
    return 0;
}
/*
输出结果是：
请输入字符串：i love studying C语言c
i love studying C语言
*/
```

我们看到，printf 中没有添加换行符 '\n'，输出时也自动换行了。

所以 fgets() 和 gets() 一样，最后的回车都会从缓冲区中取出来。只不过 gets() 是取出来丢掉，而 fgets() 是取出来自己留着。但总之缓冲区中是没有回车了！所以与 gets() 一样，在使用 fgets() 的时候，如果后面要从键盘给字符变量赋值，那么同样不需要清空缓冲区。下面写一个程序验证一下。

```c
# include <stdio.h>
int main(void)
{
    char str[30];
    char ch;
    printf("请输入字符串：");
    fgets(str, 29, stdin);
    printf("%s", str);  //后面不要加'\n'
    scanf("%c", &ch);
    printf("ch = %c\n", ch);
    return 0;
}
/*
输出结果是：
请输入字符串：i love you
i love you
Y
ch = Y
*/
```

**总**：`char *fgets(char *s, int size, FILE *stream)`函数可以从所有的记录中选妃（从文件输入流中读取，文件输入流并不局限于普通的文件，只要是流都可以用来输入），以`size-1`为界限，如果可供选择的妃子个数`>=size-1`，那么只能选择`size-1`个，最后一个位置需要`\0`来结尾，如果可供选择的妃子个数`<size-1`，那么不管是什么歪瓜裂枣都必须得选上（空格、制表符`\t`和换行符`\n`），但是在遇到换行符`\n`的情况下，读取了`\n`后直接放弃选妃。

### 输入技巧

上面展示的方法基本上足够应用大部分场景，但是有的时候，用一些特殊的方法，能让我们更有效率的接受字符串，我总结了以下几个

#### 限制每次读入的字符串长度

在百分号(%)与格式码之间添加一个整数可以限制读入的最大字符数，超出字符串的部份将留在缓冲区等待下次读取。

例如：向变量`A`读入不多于 20 个字符时的代码：

```cpp
char A[20];
scanf("%20s",&A);
```

注意读入字符串需要注意数组长度的设置，上面的例子实际上是不严谨的，因为读取到结束时候虽然会忽略空白符，但是会添加"\0"用来标识结束，如果刚好填满数组的话，会导致内存溢出，从而可能出现一些未知错误，正确的写法应该如下（假设需要读入最长20个字符的字符串）：

```cpp
char A[21];
scanf("%20s",&A);
```

最后，这种方式不仅仅局限于输入字符串，限制的长度只是限制了该方法一次性能从缓冲区看到的字符串长度，也就是说，还可以用于接收整数，浮点数等

```c
int a;
scanf("%2d",&a);
/**
* 输入"12345",运行后 a=12
*/
```

#### 读入字符但是忽略

```cpp
scanf( "%d%*c%d", &x, &y );
/**
* 输入 "10/20"
* 10放入变量x,20放入变量y,'/'被接受但是被忽略
* 这种方式可以用来匹配中间分隔符未知的情况
*/
```

#### 判断行尾

一般算法题中，根据输入一般是能确定输入中每一行的长度（或者要读取多少次），但是仍然有一些题没有明确的给出，需要手动判断或后期处理，简单举一个例子：

```text
给N行数字，每一行由纯数字组成，保证每一行的数字个数为偶数个，按相邻的两个数字为一个数（不重叠），对每一行求和并输出

如：对于123456，被分为12+34+56=102
```

对于这个问题，单纯的读取连续的两个数字，按照上面的技巧，是很容易的，格式符为`%2d`，这个问题的主要难点是我们不好判断一行什么时候结束，如果单纯的使用`scanf()`方法，没有很好的解决方案，只能通过一个字符一个字符的读取然后再组装成数字。这样实际上白白浪费了时间和精力，有没有更好的方法？当然有，那就是使用方法`sscanf()`

`sscanf()`方法和`scanf()`方法基本一样，唯一不同的是其前面多了一个参数，传递进去的是char型数组，通过该方法，我们可以先用`gets()`方法读取一整行，用`strlen()`方法求出行长度，随后我们就可以用`sscanf()`方法来二次提取，核心代码如下：

```cpp
char str[80];
gets(str);
int len = strlen(str);//需要引入cstring库或string.c
int sum = 0;
for(int i = 0;i<len/2;i++)
{
    int num;
    sscanf(str+i*2,"%2d",&num);
    sum += num;
}
```

其中第一个参数传入的是char型数组（实际上传入的是指针，`str`表示的是第1个元素所对应的位置，每加1就向下迭代一次，c里面字符串没有办法切片，但可以用这种方法更改字符串的起始位置）

## 输出

### `printf`

```c
#include <stdio.h>

int main()
{
    int a = 1;
    int b = 2;
    int c = 3;
    printf("%d\n", a++);//输出为1
    printf("%d\n", a);  //输出为2
    printf("%d\n", b++);//输出为2
    printf("%d\n", a+++b+++c++);
    //输出为8，即2+3+3的值
    return 0;
}
```

```
%d —— 以带符号的十进制形式输出整数
%f —— 以小数点形式输出单、双精度实数
%lu —— 表示输出无符号长整型整数 (long unsigned)
%u —— 以无符号的十进制形式输出整数
%c —— 以字符形式输出单个字符
%s —— 输出字符串
%p表示输出这个指针
%o —— 以无符号的八进制形式输出整数
%x —— 以无符号的十六进制形式输出整数
%e —— 以标准指数形式输出单、双精度实数
%g —— 选用输出宽度较小的格式输出实数
https://blog.csdn.net/Rodulf/article/details/51938342
```

### `putchar()`

可以看到IO方法大多都是对应着写的，该方法也一样，输出一个char类型的字符

```c
char a = 'a';
putchar(a);
putchar('b');
```

### `puts()`

`int puts(const char *str)` 把一个字符串写入到标准输出` stdout`，`puts()`方法用于输出字符串，虽然指定了格式必须是char型指针或数组，但仍然非常的便捷，尤其是该方法会自动在行尾添加换行符，不用我们手动添加换行符了。

```c
puts("hello world!");//这样是可以的

char str[80];
strcpy(str,"hello world!");
puts(str);
printf("%s\n",str);//两个方法等价
```

### 输出技巧

#### 输出精度限制

按特定精度输出的很多题的要求，主要是在输出的数字前面或者后面加0，实现方法如下：

```cpp
double d = 123.45678;
printf("%*.*f",20,10,d);

//输出:
      123.4567800000
```

两个星号分别用来指定宽度和精度，由后面的两个数指定，其中： - 精度指小数点后（不算小数点）部份的长度，不够补零，多余则是四舍五入（好像有的标准不一样[^ff](https://zhuanlan.zhihu.com/[奇进偶舍](https://zh.wikipedia.org/wiki/))，使用时可以具体测试一下） - 宽度指整个数字部份（包括小数点）的长度，如果不够则右对齐，在左侧补空格

如果要在前面补0（只能补零），则使用如下的代码：

```cpp
double d = 123.45678;
printf("%0*.*f",20,10,d);
//输出:
000000123.4567800000
```

如果要省略参数，也可以这样写，不过没有办法指定左侧补0

```cpp
double d = 123.45678;
printf("%20.10f",d);

//输出:
      123.4567800000
```

#### 输出到字符串

和`sscanf()`对应的是`sprintf()`，作用也很明显，就是将各种变量类型格式化成字符串，而`sprintf()`方法和`printf()`也几乎完全相同，只是在前面加了一个参数用来放置存放输出的字符串变量

```cpp
int a,b,d;
char str[80];
sprintf(str,"%d+%d=%d",a,b,c);
```

`void setbuf(FILE *steam, char *buf);`，`stream`为文件流指针，`buf`为缓冲区的起始地址，把缓冲区与流[相联](https://www.cnblogs.com/yeshenmeng/p/12756164.html)。

```c
#include <stdio.h>
int main()
{
    char str[BUFSIZ];
    setbuf(stdout,str);
    scanf("%s", str);
    puts("a");
    printf("%s", str);
    return 0;
}
```



`setbuf(stdout,NULL);`关闭缓存

C 库函数 `void *memset(void *str, int c, size_t n)` 复制字符 **c**（一个无符号字符）到参数 `str `所指向的字符串的前 **n** 个字符。

## 参考资料

[参考1]：https://zhuanlan.zhihu.com/p/78302619

[fgets]：http://c.biancheng.net/view/235.html


